线程池、lambda表达式

线程池概念

描述什么是线程池

线程池：其实就是一个容器，多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。

请描述合理利用线程池能够带来的三个好处。

\1. 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。

 \2. 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。

 \3. 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。

### Lambda表达式

请列举Lambda语法的省略规则

在Lambda标准格式的基础上，使用省略写法的规则为：

\1.    小括号内参数的类型可以省略；

\2.    如果小括号内有且仅有一个参，则小括号可以省略；

\3.    如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。

请列举Lambda表达式的3个组成部分，并解释说明。

Lambda标准格式 Lambda省去面向对象的条条框框，格式由3个部分组成：一些参数，一个箭头，一段代码。

Lambda表达式的标准格式为：格式说明：

\1.    小括号内的语法与传统方法参数列表一致：无参数则留空；多个参数则用逗号分隔。

\2.    ->是新引入的语法格式，代表指向动作。

\3.    大括号内的语法与传统方法体要求基本一致。

**为什么要使用线程池？如何使用线程池？线程池有哪些核心参数？初始化线程池的大小的如何算？shutdown 和 shutdownNow 有什么区别？**

1、为什么要使用线程池？

**(1)、降低资源消耗。** 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。

**(2)、提高响应速度。** 当任务到达时，任务可以不需要等到线程创建就能立即执行。

**(3)、提高线程的可管理性。** 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

> 线程池可以认为是更普遍的 “池化资源” 技术的一个示例，其产生的原因是，由于创建 / 销毁对象需要对内存资源或者其他相关资源进行相对操作，所以某些消耗资源的对象的创建和销毁是比较费事的（java 虚拟机还需要管理每一个对象的生命周期），所以资源优化的一个方向就是减少创建和销毁对象的次数，尽可能地复用。比如说数据库连接池；

2、如何使用线程池？

工具类 Executors 提供了静态工厂方法以生成常用的线程池：

(1)、newSingleThreadExecutor：创建一个单线程的线程池。如果该线程因为异常而结束，那么会有一个新的线程来替代它。

(2)、newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大值，一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。

(3)、newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（默认 60 秒不执行任务）的线程。当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。

(4)、newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。

3、java 线程池的核心参数

Executors 也提供自定义的线程池构造方法，里面包括七个参数：

public ThreadPoolExecutor ( int corePoolSize, // 常驻线程数，即使空闲时仍保留在池中的线程数
int maximumPoolSize, // 线程池中允许的最大线程数
long keepAliveTime, // 存活时间。线程数比 corePoolSize 多且处于闲置状态的情况下，这些闲置的线程能存活的最大时间，为 0 表示会立即回收；
TimeUnit unit, //keepAliveTime 的单位
BlockingQueue workQueue, // 被提交尚未被执行的任务阻塞队
ThreadFactory threadFactory, // 创建线程的工厂
RejectedExecutionHandler handler // 饱和拒绝策略，当队列满了并且线程个数达到 maximunPoolSize 后采取的策略。目前支付四种：AbortPolicy (抛出异常)，CallerRunsPolicy (调用者线程处理)，DiscardOldestPolicy (直接丢弃任务，不予处理也不抛出异常)，DiscardPolicy (默默丢弃，不抛出异常)
)

4、如何设置初始化线程池的大小？

可根据线程池中的线程处理任务的不同进行分别估计：

(1)、CPU 密集型任务，这类任务需要大量的运算，通常 CPU 利用率很高，无阻塞，因此应配置尽可能少的线程数量，可设置为 CPU 核数 + 1；

(2)、IO 密集型任务，这类任务有大量 IO 操作，伴随着大量线程被阻塞，可配置更多的线程数，通常可设置 CPU 核心数 * 2；

> 这个问题其实并非要候选人提出一个天衣无缝的初始线程数，这在实际工程中既无必要（可以逐渐优化调整），也很难实施（服务器上不止一个 java 应用），而是考察候选人结构化的思维能力，针对一个相对陌生或者相对复杂的问题，如何去分析思考。因此回答这类题，需要做到有据可循、言之有物。简单地说，就是能圆回来。针对这类问题有一个**简单的技巧**，就是先分类，然后针对不同的分类分别回答，这样结构会更清晰，考虑也更全面，而且一般这种偏开放式的问题，本身也很难说有一个答案可以覆盖所有场景。

5、shutdown 和 shutdownNow 有什么区别？

shutdown，有序停止。将线程池状态设置为 SHUTDOWN

(1)、停止接收外部提交的任务；

(2)、先前提交的任务务会执行（但不保证完成执行）；

shutdownNow，尝试立即停止，将线程池状态设置为 STOP，相对来说是一种更优雅的关闭方法。

(1)、停止接收外部提交的任务；

(2)、不再处理队列里等待的任务；

(3)、忽略队列里等待的任务；

(4)、返回正在等待执行的任务列表；

> shutdownNow 试图取消线程的方法是通过调用 Thread.interrupt () 方法来实现的，非强制的，如果线程中没有 sleep/wait 等应用，interrupt () 方法是无法中断当前的线程的。所以，ShutdownNow 并不代表线程池就一定立即就能退出，它也可能必须要等待所有正在执行的任务都执行完成了才能退出，但是大多数时候是能立即退出的

**点评**：

这是典型的线程池面试题，采用一环扣一环 / 层层递进的追问问法，目的在于有效评测候选者的知识深度，有时候会追问到候选者答不上为止。对应的方式就是要**熟练掌握相关类（特别是 Executors 类）的用法和代码**，最好平常有使用经验。常见的其他考察还有任务执行、线程池容量动态调整等内容，可以参见扩展阅读部分内容。